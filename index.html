<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Arena Pi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#1d1f27;
      --fg:#e8e8ee;
      --card:#2a2d3a;
      --accent:#7d7aff;
      --wood-light:#d5a64f;
      --wood-dark:#b07f2d;
      --frame:#6f4e1f;
      --square-light:#f0d9b5;
      --square-dark:#b58863;
    }
    * {box-sizing:border-box;}
    body {
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:1.5rem;
      gap:30px;
    }
    .card {
      width:100%;
      max-width: 660px;
      background: var(--card);
      border-radius:18px;
      padding:2rem 1.75rem 2.5rem;
      box-shadow:0 50px 120px -10px rgba(0,0,0,0.5);
      text-align:center;
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
    }
    .logo {
      width: 140px;
      height: 140px;
      display:flex;
      align-items:center;
      justify-content:center;
      margin:0;
      opacity:0;
      animation: bounceIn .7s ease-out forwards, pulse 2.5s ease-in-out .7s infinite;
    }
    @keyframes bounceIn {
      0% { transform: translateY(50px) scale(.7); opacity:0; }
      60% { transform: translateY(-6px) scale(1.08); opacity:1; }
      100% { transform: translateY(0) scale(1); }
    }
    @keyframes pulse {
      0%,100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .welcome {
      font-size:3rem;
      font-weight:700;
      margin:0;
      line-height:1;
    }
    .sub {
      font-size:1.1rem;
      margin:0;
      text-transform:uppercase;
      opacity:.85;
      letter-spacing:1px;
    }
    .btn {
      cursor:pointer;
      padding:16px 28px;
      border:none;
      border-radius:14px;
      font-size:1.3rem;
      font-weight:700;
      background: linear-gradient(135deg,var(--accent),#8f9fff);
      color:#fff;
      margin-top:8px;
      min-width:200px;
      box-shadow:0 25px 80px -5px rgba(127,127,255,0.6);
      transition:filter .15s;
    }
    .btn:active {filter:brightness(.9);}
    .small-text {
      font-size:0.85rem;
      margin-top:6px;
      opacity:.85;
    }
    .board-container {
      display:none;
      position:relative;
      width:100%;
      max-width: 700px;
      padding:20px;
      background: linear-gradient(135deg,var(--wood-light) 0%, var(--wood-dark) 100%);
      border-radius:18px;
      box-shadow:0 60px 140px -10px rgba(0,0,0,0.5);
      margin-top:10px;
      animation: popIn .4s cubic-bezier(.4,0,.2,1) forwards;
    }
    @keyframes popIn {
      0% { transform: scale(.7); opacity:0; }
      60% { transform: scale(1.05); opacity:1; }
      100% { transform: scale(1); }
    }
    .board-frame {
      background: var(--frame);
      padding:8px;
      border-radius:12px;
      display:flex;
      justify-content:center;
    }
    .board {
      position: relative;
      width:560px;
      aspect-ratio:1;
      display:grid;
      grid-template: repeat(8, 1fr) / repeat(8, 1fr);
      border-radius:8px;
      overflow:hidden;
      box-shadow: inset 0 0 40px rgba(0,0,0,0.3);
    }
    .square {
      position: relative;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:0;
      user-select:none;
    }
    .square.light { background: var(--square-light); }
    .square.dark { background: var(--square-dark); }
    .piece {
      width:80%;
      height:80%;
      cursor:grab;
      touch-action: none;
    }
    .highlight {
      outline:3px solid #ffd33f;
      outline-offset:-3px;
      border-radius:4px;
    }
    .status {
      margin-top:12px;
      font-size:1rem;
      font-weight:600;
    }
    .small-note {
      font-size:0.65rem;
      margin-top:6px;
      opacity:.6;
      text-align:center;
    }
    .fade {
      transition: opacity .2s;
    }
  </style>
</head>
<body>
  <!-- Audio contexts for sounds -->
  <script>
    // Pre-create audio contexts for reuse
    let audioCtx;
    function ensureCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    function playPinDrop() {
      ensureCtx();
      const ctx = audioCtx;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(900, ctx.currentTime);
      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.frequency.exponentialRampToValueAtTime(250, ctx.currentTime + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
      osc.start();
      osc.stop(ctx.currentTime + 0.25);
    }
    function playClick() {
      ensureCtx();
      const ctx = audioCtx;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      gain.gain.setValueAtTime(0.1, ctx.currentTime);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.07);
    }
    function playMoveTone() {
      ensureCtx();
      const ctx = audioCtx;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(480, ctx.currentTime);
      gain.gain.setValueAtTime(0.08, ctx.currentTime);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.05);
    }
  </script>

  <div class="card" aria-label="Welcome card">
    <div class="logo" aria-label="Pawn logo">
      <svg width="96" height="96" viewBox="0 0 64 64" aria-hidden="true" style="display:block; color: #e8e8ee;">
        <circle cx="32" cy="16" r="10" fill="currentColor" />
        <path d="M22 52c0-8 20-8 20 0H22z" fill="currentColor" />
        <path d="M24 44h16v8H24z" fill="currentColor" />
        <path d="M16 56h32v4H16z" fill="currentColor" />
      </svg>
    </div>
    <div class="welcome">welcome</div>
    <div class="sub">The Chess Arena Pi</div>
    <button class="btn" id="start-btn">Start</button>
    <div class="small-text" id="start-msg">Tap start to begin the game.</div>
  </div>

  <div class="board-container" id="board-container" aria-label="Chess board area">
    <div class="board-frame">
      <div class="board" id="board" aria-label="Chessboard"></div>
    </div>
    <div class="status" id="status">Loading...</div>
    <div class="small-note">Turn-based FIDE movement enforcement (white starts). Click/tap and drag to move. Basic check/checkmate detection.</div>
  </div>

  <script>
    // Pawn bounce + pin drop
    window.addEventListener("load", () => {
      const logo = document.querySelector(".logo");
      setTimeout(() => {
        logo.style.opacity = "1";
        playPinDrop();
      }, 120);
    });

    // Chess logic (simplified FIDE rules: move generation for basic pieces, no en passant/castling/promotion UI beyond pawn reaching end)
    const initialFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w";
    let gameState = null; // will be object
    let selected = null;
    let legalMovesCache = [];

    const pieceSVGs = {
      P: `<svg viewBox="0 0 45 45" aria-label="White Pawn"><circle cx="22.5" cy="12" r="6" fill="#ffffff"/><path d="M12 33c0-8 21-8 21 0H12z" fill="#ffffff"/><path d="M14 27h17v6H14z" fill="#f0f0ff"/><path d="M8 36h29v3H8z" fill="#d1d1f0"/></svg>`,
      R: `<svg viewBox="0 0 45 45" aria-label="White Rook"><rect x="12" y="12" width="21" height="6" fill="#ffffff"/><path d="M12 18h21v15H12z" fill="#ffffff"/><path d="M10 33h25v4H10z" fill="#d1d1f0"/></svg>`,
      N: `<svg viewBox="0 0 45 45" aria-label="White Knight"><path d="M22.5 12c-6 0-12 8-12 12v7h24v-7c0-4-6-12-12-12z" fill="#ffffff"/><circle cx="22.5" cy="30" r="3" fill="#d1d1f0"/></svg>`,
      B: `<svg viewBox="0 0 45 45" aria-label="White Bishop"><path d="M22.5 12c-5 0-12 8-12 12v7h24v-7c0-4-7-12-12-12z" fill="#ffffff"/><circle cx="22.5" cy="30" r="3" fill="#d1d1f0"/></svg>`,
      Q: `<svg viewBox="0 0 45 45" aria-label="White Queen"><circle cx="22.5" cy="12" r="5" fill="#ffffff"/><path d="M12 18h21v15H12z" fill="#ffffff"/><path d="M10 33h25v4H10z" fill="#d1d1f0"/></svg>`,
      K: `<svg viewBox="0 0 45 45" aria-label="White King"><path d="M20 12h5v5h-5z" fill="#ffffff"/><path d="M12 18h21v15H12z" fill="#ffffff"/><path d="M10 33h25v4H10z" fill="#d1d1f0"/></svg>`,
      p: `<svg viewBox="0 0 45 45" aria-label="Black Pawn"><circle cx="22.5" cy="12" r="6" fill="#1f1f28"/><path d="M12 33c0-8 21-8 21 0H12z" fill="#1f1f28"/><path d="M14 27h17v6H14z" fill="#2f2f3a"/><path d="M8 36h29v3H8z" fill="#3f3f55"/></svg>`,
      r: `<svg viewBox="0 0 45 45" aria-label="Black Rook"><rect x="12" y="12" width="21" height="6" fill="#1f1f28"/><path d="M12 18h21v15H12z" fill="#1f1f28"/><path d="M10 33h25v4H10z" fill="#3f3f55"/></svg>`,
      n: `<svg viewBox="0 0 45 45" aria-label="Black Knight"><path d="M22.5 12c-6 0-12 8-12 12v7h24v-7c0-4-6-12-12-12z" fill="#1f1f28"/><circle cx="22.5" cy="30" r="3" fill="#3f3f55"/></svg>`,
      b: `<svg viewBox="0 0 45 45" aria-label="Black Bishop"><path d="M22.5 12c-5 0-12 8-12 12v7h24v-7c0-4-7-12-12-12z" fill="#1f1f28"/><circle cx="22.5" cy="30" r="3" fill="#3f3f55"/></svg>`,
      q: `<svg viewBox="0 0 45 45" aria-label="Black Queen"><circle cx="22.5" cy="12" r="5" fill="#1f1f28"/><path d="M12 18h21v15H12z" fill="#1f1f28"/><path d="M10 33h25v4H10z" fill="#3f3f55"/></svg>`,
      k: `<svg viewBox="0 0 45 45" aria-label="Black King"><path d="M20 12h5v5h-5z" fill="#1f1f28"/><path d="M12 18h21v15H12z" fill="#1f1f28"/><path d="M10 33h25v4H10z" fill="#3f3f55"/></svg>`
    };

    // Parse FEN into board array
    function loadFEN(fen) {
      const parts = fen.split(" ");
      const rows = parts[0].split("/");
      const board = [];
      for (let r = 0; r < 8; r++) {
        const row = [];
        for (let i = 0; i < rows[r].length; i++) {
          const c = rows[r][i];
          if (/\d/.test(c)) {
            const count = parseInt(c, 10);
            for (let j = 0; j < count; j++) row.push(null);
          } else {
            row.push(c);
          }
        }
        board.push(row);
      }
      const turn = parts[1] === "w" ? "w" : "b";
      return { board, turn };
    }

    // Convert board to FEN (simplified, no castling/en passant)
    function boardToFEN(state) {
      const rows = state.board.map(row => {
        let s = "";
        let empty = 0;
        row.forEach(cell => {
          if (cell === null) { empty++; }
          else {
            if (empty) { s += empty; empty = 0; }
            s += cell;
          }
        });
        if (empty) s += empty;
        return s;
      });
      return rows.join("/") + " " + state.turn;
    }

    // Basic move generation for king, queen, rook, bishop, knight, pawn
    function generateMoves(state, from) {
      const moves = [];
      const [fr, fc] = from;
      const piece = state.board[fr][fc];
      if (!piece) return moves;
      const isWhite = piece === piece.toUpperCase();
      const dirs = {
        P: [[-1,0],[-2,0],[-1,-1],[-1,1]],
        p: [[1,0],[2,0],[1,-1],[1,1]],
        N: [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
        n: [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
      };
      const opponent = isWhite ? /[a-z]/ : /[A-Z]/;

      const inBounds = (r,c)=> r>=0&&r<8&&c>=0&&c<8;
      if (piece.toUpperCase() === "P") {
        const dir = piece === "P" ? -1 : 1;
        // single
        if (inBounds(fr+dir, fc) && !state.board[fr+dir][fc]) {
          moves.push([fr+dir, fc]);
          // double from starting rank
          const startRank = piece === "P" ? 6 : 1;
          if (fr === startRank && !state.board[fr+2*dir][fc]) {
            moves.push([fr+2*dir, fc]);
          }
        }
        // captures
        for (let dc of [-1,1]) {
          const nr=fr+dir, nc=fc+dc;
          if (inBounds(nr,nc) && state.board[nr][nc] && opponent.test(state.board[nr][nc])) {
            moves.push([nr,nc]);
          }
        }
      } else if (piece.toUpperCase() === "N") {
        for (let d of dirs.N) {
          const nr=fr+d[0], nc=fc+d[1];
          if (!inBounds(nr,nc)) continue;
          const target = state.board[nr][nc];
          if (!target || (isWhite ? /[a-z]/ : /[A-Z]/).test(target)) {
            moves.push([nr,nc]);
          }
        }
      } else if (["B","R","Q","K"].includes(piece.toUpperCase())) {
        const vectors = {
          B: [[-1,-1],[-1,1],[1,-1],[1,1]],
          R: [[-1,0],[1,0],[0,-1],[0,1]],
          Q: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
          K: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
        }[piece.toUpperCase()];
        for (let v of vectors) {
          let nr=fr+v[0], nc=fc+v[1];
          while (inBounds(nr,nc)) {
            const target = state.board[nr][nc];
            if (!target) {
              moves.push([nr,nc]);
            } else {
              if (isWhite ? /[a-z]/ : /[A-Z]/).test(target) moves.push([nr,nc]);
              break;
            }
            if (piece.toUpperCase()==="K") break;
            nr+=v[0]; nc+=v[1];
          }
        }
      }
      // Note: No en passant, castling, or promotion choice UI (pawn auto-promotes to queen)
      return moves;
    }

    function isKingInCheck(state, color) {
      // find king
      let kingPos=null;
      const target = color === "w" ? "K" : "k";
      for (let r=0;r<8;r++) for (let c=0;c<8;c++)
        if (state.board[r][c] === target) kingPos=[r,c];
      if (!kingPos) return true; // missing king
      // for each opponent piece, see if it can capture king
      const opponentColor = color==="w" ? "b" : "w";
      for (let r=0;r<8;r++) for (let c=0;c<8;c++) {
        const p = state.board[r][c];
        if (!p) continue;
        const isWhite = p === p.toUpperCase();
        if ((opponentColor==="w" && isWhite) || (opponentColor==="b" && !isWhite)) {
          const moves = generateMoves(state, [r,c]);
          for (let m of moves) {
            if (m[0] === kingPos[0] && m[1] === kingPos[1]) return true;
          }
        }
      }
      return false;
    }

    function cloneState(state) {
      return { board: state.board.map(r=>r.slice()), turn: state.turn };
    }

    function movePiece(state, from, to) {
      const piece = state.board[from[0]][from[1]];
      if (!piece) return false;
      const moves = generateMoves(state, from);
      const valid = moves.some(m=>m[0]===to[0] && m[1]===to[1]);
      if (!valid) return false;
      const newState = cloneState(state);
      // handle pawn promotion (to queen) automatically
      if ((piece === "P" && to[0] === 0) || (piece === "p" && to[0] === 7)) {
        newState.board[to[0]][to[1]] = piece === "P" ? "Q" : "q";
      } else {
        newState.board[to[0]][to[1]] = piece;
      }
      newState.board[from[0]][from[1]] = null;
      // change turn
      newState.turn = state.turn === "w" ? "b" : "w";
      // if move leaves own king in check, illegal
      if (isKingInCheck(newState, state.turn)) return false;
      Object.assign(state, newState);
      return true;
    }

    // Check for basic checkmate/stalemate
    function hasLegalMoves(state) {
      for (let r=0;r<8;r++) for (let c=0;c<8;c++) {
        const p = state.board[r][c];
        if (!p) continue;
        const isWhite = p === p.toUpperCase();
        if ((state.turn==="w" && isWhite) || (state.turn==="b" && !isWhite)) {
          const moves = generateMoves(state, [r,c]);
          for (let m of moves) {
            const test = cloneState(state);
            if (movePiece(test, [r,c], m)) return true;
          }
        }
      }
      return false;
    }

    // Render
    const boardEl = document.getElementById("board");
    const statusEl = document.getElementById("status");

    function render(state) {
      boardEl.innerHTML = "";
      for (let r=0;r<8;r++) {
        for (let c=0;c<8;c++) {
          const sq = document.createElement("div");
          const isLight = ((r + c) % 2 === 0);
          sq.className = "square " + (isLight ? "light" : "dark");
          sq.dataset.coord = String.fromCharCode(97 + c) + (8 - r);
          if (state.board[r][c]) {
            const pieceWrapper = document.createElement("div");
            pieceWrapper.className = "piece";
            pieceWrapper.dataset.piece = state.board[r][c];
            pieceWrapper.innerHTML = pieceSVGs[state.board[r][c]] || "";
            pieceWrapper.draggable = false;
            sq.appendChild(pieceWrapper);
          }
          boardEl.appendChild(sq);
        }
      }
      updateStatus(state);
    }

    function updateStatus(state) {
      const inCheck = isKingInCheck(state, state.turn);
      const hasMoves = hasLegalMoves(state);
      if (!hasMoves) {
        if (inCheck) {
          statusEl.textContent = (state.turn === "w" ? "White" : "Black") + " is checkmated. Game over.";
        } else {
          statusEl.textContent = "Stalemate. Game over.";
        }
      } else {
        statusEl.textContent = (state.turn === "w" ? "White" : "Black") + (inCheck ? " (in check)" : "") + " to move.";
      }
    }

    // Drag / drop interaction
    let drag = null;
    boardEl.addEventListener("pointerdown", (e) => {
      const target = e.target.closest(".piece");
      if (!target) return;
      e.preventDefault();
      const square = target.closest(".square");
      const fromCoord = square.dataset.coord;
      const from = coordToRC(fromCoord);
      const piece = target.dataset.piece;
      if ((gameState.turn === "w" && piece === piece.toUpperCase()) ||
          (gameState.turn === "b" && piece === piece.toLowerCase())) {
        const possible = generateMoves(gameState, from).filter(m => {
          // filter out moves that would leave king in check
          const test = cloneState(gameState);
          return movePiece(test, from, m);
        });
        if (possible.length === 0) return;
        // highlight
        clearHighlights();
        square.classList.add("highlight");
        possible.forEach(m => {
          const coord = rcToCoord(m);
          const sq = boardEl.querySelector(`[data-coord="${coord}"]`);
          if (sq) sq.classList.add("highlight");
        });
        drag = { pieceElem: target, from, possible };
        target.setPointerCapture(e.pointerId);
      }
    });
    boardEl.addEventListener("pointerup", (e) => {
      if (!drag) return;
      const under = document.elementFromPoint(e.clientX, e.clientY);
      const destSq = under?.closest(".square");
      if (destSq) {
        const to = coordToRC(destSq.dataset.coord);
        const moved = movePiece(gameState, drag.from, to);
        if (moved) {
          playMoveTone();
        } else {
          playClick();
        }
        render(gameState);
      }
      clearHighlights();
      drag = null;
    });

    function clearHighlights() {
      boardEl.querySelectorAll(".highlight").forEach(el => el.classList.remove("highlight"));
    }

    function coordToRC(coord) {
      const file = coord[0].charCodeAt(0) - 97;
      const rank = parseInt(coord[1], 10);
      return [8 - rank, file];
    }
    function rcToCoord([r,c]) {
      return String.fromCharCode(97 + c) + (8 - r);
    }

    // Initialize on start
    document.getElementById("start-btn").addEventListener("click", () => {
      playClick();
      gameState = loadFEN(initialFEN);
      render(gameState);
      document.getElementById("board-container").style.display = "block";
      document.getElementById("start-msg").textContent = "Game started."; 
    });
  </script>
</body>
</html>
