<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>The Chess Arena Pi</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg:#0f172a;
    --card:#1f2937;
    --text:#e2e8f0;
    --light-square:#f0fff4;
    --dark-square:#c8facc;
    --khaki:#b7a97a;
    --black-piece:#1f1f1f;
    --radius:14px;
    --shadow:0 30px 70px -10px rgba(0,0,0,0.45);
    --transition:.35s cubic-bezier(.4,.2,.2,1);
  }
  [data-theme="light"] {
    --bg:#f0f5fa;
    --card:#ffffff;
    --text:#1f2d3d;
  }
  *{box-sizing:border-box;}
  body {
    margin:0;
    font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
    background:linear-gradient(135deg,#0f172a 0%,#1f2937 85%);
    color: var(--text);
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:1rem;
    transition: background var(--transition), color var(--transition);
  }
  .hidden { display:none; }
  .app {
    width:100%;
    max-width:1100px;
    display:grid;
    gap:1rem;
    grid-template-columns:1fr;
  }
  .top {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    gap:12px;
    align-items:center;
    margin-bottom:6px;
  }
  .logo {
    display:flex;
    align-items:center;
    gap:10px;
    font-weight:700;
    font-size:1.25rem;
  }
  .logo img {
    width:44px;
    height:44px;
    object-fit:contain;
    border-radius:10px;
    background:rgba(255,255,255,0.08);
    padding:6px;
  }
  .controls {
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .btn {
    background:#10b981;
    border:none;
    padding:10px 16px;
    border-radius:999px;
    cursor:pointer;
    font-weight:600;
    display:inline-flex;
    align-items:center;
    gap:6px;
    position:relative;
    transition:filter .2s;
  }
  .btn:hover { filter:brightness(1.1); }
  .small-btn {
    background:rgba(255,255,255,0.08);
    border:none;
    padding:8px 12px;
    border-radius:999px;
    cursor:pointer;
    font-size:0.8rem;
    color:inherit;
    display:inline-flex;
    align-items:center;
    gap:4px;
  }
  .card {
    background: var(--card);
    border-radius:16px;
    padding:18px;
    display:grid;
    gap:12px;
    box-shadow: var(--shadow);
    position:relative;
    overflow:hidden;
  }
  .status-bar {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    font-size:0.9rem;
  }
  .board-wrapper {
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
  }
  .board {
    width:100%;
    max-width:560px;
    aspect-ratio:1;
    display:grid;
    border:4px solid rgba(255,255,255,0.07);
    border-radius:14px;
    position:relative;
    user-select:none;
    background:#222e55;
  }
  .square {
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:1.4rem;
    cursor:pointer;
    transition:background .25s;
  }
  .light { background: var(--light-square); }
  .dark { background: var(--dark-square); }
  .piece {
    width:65%;
    height:65%;
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    user-select:none;
    pointer-events:none;
    font-size:1rem;
  }
  .piece.khaki { background: var(--khaki); color:#1f2d3d; }
  .piece.black { background: var(--black-piece); color:#fff; }
  .highlight { outline:3px solid rgba(255,255,255,0.8); }
  .timer-box {
    display:inline-flex;
    gap:6px;
    align-items:center;
    font-weight:700;
    padding:6px 10px;
    border-radius:999px;
    background:rgba(255,255,255,0.08);
  }
  .move-history {
    overflow-x:auto;
    font-size:0.8rem;
    padding:6px 10px;
    border-radius:10px;
    background:rgba(255,255,255,0.05);
    margin-top:4px;
    white-space:nowrap;
  }
  .winner {
    font-weight:700;
    font-size:1.1rem;
    margin-top:4px;
  }
  .theme-toggle {
    background:rgba(255,255,255,0.08);
    border:none;
    padding:8px 12px;
    border-radius:999px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:0.9rem;
  }
  .placeholder {
    background:rgba(255,255,255,0.04);
    border:2px dashed rgba(255,255,255,0.2);
    padding:12px;
    border-radius:12px;
    font-size:0.8rem;
    margin-top:6px;
  }
  .welcome {
    position:fixed;
    inset:0;
    background:rgba(15,23,42,0.96);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:18px;
    padding:24px;
    text-align:center;
    z-index:99;
    color:#fff;
  }
  .welcome h1 {
    margin:0;
    font-size:2.1rem;
    letter-spacing:0.5px;
  }
  .welcome p {
    margin:0;
    font-size:1rem;
    max-width:500px;
  }
  .pulse {
    width:14px;
    height:14px;
    border-radius:50%;
    background:#fff;
    animation:pulse 1.8s infinite;
    margin-right:6px;
  }
  @keyframes pulse {
    0% { transform:scale(.9); opacity:.5; }
    50% { transform:scale(1.3); opacity:1; }
    100% { transform:scale(.9); opacity:.5; }
  }
  .flex { display:flex; align-items:center; gap:6px; }
</style>
</head>
<body data-theme="dark">
  <div class="welcome" id="welcome-screen">
    <div class="flex">
      <div class="pulse" aria-hidden="true"></div>
      <h1>The Chess Arena Pi</h1>
    </div>
    <p>Khaki vs Black. Turn timer. AI opponent. No fluff. Ready to play?</p>
    <div>
      <button class="btn" id="begin-btn">Start</button>
    </div>
  </div>

  <div class="app" aria-label="Chess Arena app">
    <div class="top">
      <div class="logo" aria-label="logo">
        <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA4MDAgODAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxjaXJjbGUgY3g9IjQwMCIgY3k9IjQwMCIgcj0iMzgwIiBmaWxsPSIjMTBiOTgxIi8+CiAgPHRleHQgeD0iNDAwIiB5PSI0NTAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjIwMCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZiI+PC90ZXh0Pgo8L3N2Zz4=" alt="logo" />
        <div>Chess Arena Pi</div>
      </div>
      <div class="controls">
        <div class="timer-box" aria-label="turn timer">
          <div>Turn Time</div>
          <div><span id="timer-display">30</span>s</div>
        </div>
        <div id="turn-indicator" style="font-weight:600;">You: Khaki</div>
        <button class="small-btn" id="play-ai">
          <div class="pulse" aria-hidden="true" style="margin:0;"></div>
          Play Vs AI
        </button>
        <button class="small-btn" id="reset-btn">Reset</button>
        <button class="small-btn" id="undo-btn">Undo</button>
        <button class="theme-toggle" id="theme-toggle">ðŸŒ™</button>
      </div>
    </div>

    <div class="card" aria-label="game card">
      <div class="status-bar">
        <div>Moves:</div>
        <div class="move-history" id="move-history">-</div>
        <div class="winner" id="winner-announcement"></div>
      </div>
      <div class="board-wrapper">
        <div class="board" id="board" role="grid" aria-label="chess board"></div>
      </div>
    </div>

    <div class="card" aria-label="Pi SDK placeholder">
      <div style="font-weight:600; margin-bottom:6px;">Pi SDK Placeholder</div>
      <div class="placeholder">
        <!-- Insert Pi Network login/integration here.
             Example:
             <script src="...pi-sdk.js"></script>
             <script>
               // initialize Pi authentication
             </script>
        -->
        Game logic is independent; login can layer on later.
      </div>
    </div>
  </div>

  <!-- Audio for effects -->
  <audio id="tick-sound">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <audio id="move-sound">
    <source src="data:audio/wav;base64,UklGRhIAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <audio id="win-sound">
    <source src="data:audio/wav;base64,UklGRi4AAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <audio id="lose-sound">
    <source src="data:audio/wav;base64,UklGRi4AAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav">
  </audio>

<script>
  // --- game state ---
  const boardEl = document.getElementById('board');
  const timerDisplay = document.getElementById('timer-display');
  const turnIndicator = document.getElementById('turn-indicator');
  const moveHistoryEl = document.getElementById('move-history');
  const winnerAnn = document.getElementById('winner-announcement');

  let board = [];
  let turn = 'khaki'; // 'khaki' player first; alternates each reset
  let playerColor = 'khaki'; // current player color
  let selected = null;
  let history = [];
  let fullHistory = []; // for undo including captures
  let timer = 30;
  let timerInterval = null;
  let gameOver = false;
  let enPassantTarget = null; // square [r,c] that can be captured en passant
  let canCastle = {
    khaki: {king:true, rookA:true, rookH:true},
    black: {king:true, rookA:true, rookH:true}
  };

  const initialSetup = () => ([
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['kP','kP','kP','kP','kP','kP','kP','kP'],
    ['kR','kN','kB','kQ','kK','kB','kN','kR'],
  ]);

  const clone = (o)=> JSON.parse(JSON.stringify(o));

  function resetGame(fullReset=true){
    if(fullReset){
      board = initialSetup();
      playerColor = (playerColor==='khaki'?'black':'khaki'); // alternate colors each game
      turn = playerColor; // player always starts with their current color
      canCastle = {
        khaki: {king:true, rookA:true, rookH:true},
        black: {king:true, rookA:true, rookH:true}
      };
      enPassantTarget = null;
      history = [];
      fullHistory = [];
      gameOver = false;
      winnerAnn.textContent = '';
    }
    resetTimer();
    updateUI();
    startTurnTimer();
  }

  // --- helpers ---
  function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
  function isOwn(r,c,side){
    const v=board[r][c]; if(!v) return false;
    return side==='khaki' ? v[0]==='k' : v[0]==='b';
  }
  function isOpp(r,c,side){
    const v=board[r][c]; if(!v) return false;
    return side==='khaki' ? v[0]==='b' : v[0]==='k';
  }
  function pieceAt(r,c){ return board[r][c]; }
  function setPiece(r,c,v){ board[r][c]=v; }

  function coordsToAlgebraic([r,c]){
    const file = String.fromCharCode(97+c);
    const rank = 8 - r;
    return file+rank;
  }
  function algebraicToCoords(s){
    const file = s[0].charCodeAt(0)-97;
    const rank = 8 - parseInt(s[1]);
    return [rank,file];
  }

  // --- move generation (simplified but includes castling/en passant/promotion) ---
  function generateMoves(side){
    const moves = [];
    for(let r=0;r<8;r++){
      for(let c=0;c<8;c++){
        const cell = board[r][c];
        if(!cell) continue;
        if(side==='khaki' && cell[0]!=='k') continue;
        if(side==='black' && cell[0]!=='b') continue;
        const type = cell[1];
        const origin = [r,c];
        if(type==='P'){
          const dir = side==='khaki' ? -1 : 1;
          // one forward
          if(inBounds(r+dir,c) && !board[r+dir][c]){
            // promotion?
            if((side==='khaki' && r+dir===0) || (side==='black' && r+dir===7)){
              moves.push({from:origin,to:[r+dir,c],promotion:true});
            } else {
              moves.push({from:origin,to:[r+dir,c]});
            }
            // two forward
            if((side==='khaki' && r===6) || (side==='black' && r===1)){
              if(!board[r+dir*2][c]){
                moves.push({from:origin,to:[r+dir*2,c],double:true});
              }
            }
          }
          // captures
          for(const dc of [-1,1]){
            const nr=r+dir, nc=c+dc;
            if(inBounds(nr,nc)){
              if(isOpp(nr,nc,side)){
                if((side==='khaki' && nr===0) || (side==='black' && nr===7)){
                  moves.push({from:origin,to:[nr,nc],capture:true,promotion:true});
                } else {
                  moves.push({from:origin,to:[nr,nc],capture:true});
                }
              }
              // en passant
              if(enPassantTarget && nr===enPassantTarget[0] && nc===enPassantTarget[1]){
                moves.push({from:origin,to:[nr,nc],enpassant:true});
              }
            }
          }
        } else if(type==='R' || type==='Q' || type==='B'){
          const straight = (type==='R' || type==='Q');
          const diag = (type==='B' || type==='Q');
          const deltas = [];
          if(straight) deltas.push([1,0],[-1,0],[0,1],[0,-1]);
          if(diag) deltas.push([1,1],[1,-1],[-1,1],[-1,-1]);
          for(const d of deltas){
            let nr=r+d[0], nc=c+d[1];
            while(inBounds(nr,nc)){
              if(isOwn(nr,nc,side)) break;
              if(isOpp(nr,nc,side)){
                moves.push({from:origin,to:[nr,nc],capture:true});
                break;
              }
              moves.push({from:origin,to:[nr,nc]});
              nr+=d[0]; nc+=d[1];
            }
          }
        } else if(type==='N'){
          const deltas = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
          for(const d of deltas){
            const nr=r+d[0], nc=c+d[1];
            if(inBounds(nr,nc) && !isOwn(nr,nc,side)){
              if(isOpp(nr,nc,side)){
                moves.push({from:origin,to:[nr,nc],capture:true});
              } else {
                moves.push({from:origin,to:[nr,nc]});
              }
            }
          }
        } else if(type==='K'){
          const deltas = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
          for(const d of deltas){
            const nr=r+d[0], nc=c+d[1];
            if(inBounds(nr,nc) && !isOwn(nr,nc,side)){
              if(isOpp(nr,nc,side)){
                moves.push({from:origin,to:[nr,nc],capture:true});
              } else {
                moves.push({from:origin,to:[nr,nc]});
              }
            }
          }
          // castling (very naive, no check detection)
          if(canCastle[side].king){
            // king-side
            if(canCastle[side].rookH){
              const empty1 = board[r][5]==='' && board[r][6]==='';
              if(empty1){
                moves.push({from:origin,to:[r,6],castle:'king'});
              }
            }
            // queen-side
            if(canCastle[side].rookA){
              const empty2 = board[r][1]==='' && board[r][2]==='' && board[r][3]==='';
              if(empty2){
                moves.push({from:origin,to:[r,2],castle:'queen'});
              }
            }
          }
        }
      }
    }
    return moves;
  }

  function applyMove(m){
    const [fr,fc] = m.from;
    const [tr,tc] = m.to;
    const piece = board[fr][fc];
    const snapshot = {board: clone(board), enPassantTarget, canCastle: JSON.parse(JSON.stringify(canCastle))};
    fullHistory.push(snapshot);
    // handle en passant capture
    if(m.enpassant){
      // capture pawn behind
      if(turn==='khaki'){
        board[tr+1][tc]='';
      } else {
        board[tr-1][tc]='';
      }
    }
    // handle castling
    if(m.castle){
      // move rook accordingly
      if(m.castle==='king'){
        board[tr][tc]=piece;
        board[fr][fc]='';
        if(turn==='khaki'){
          board[7][5]=board[7][7];
          board[7][7]='';
        } else {
          board[0][5]=board[0][7];
          board[0][7]='';
        }
        canCastle[turn].king=false;
        canCastle[turn].rookH=false;
        history.push(m);
        enPassantTarget=null;
        return;
      } else if(m.castle==='queen'){
        board[tr][tc]=piece;
        board[fr][fc]='';
        if(turn==='khaki'){
          board[7][3]=board[7][0];
          board[7][0]='';
        } else {
          board[0][3]=board[0][0];
          board[0][0]='';
        }
        canCastle[turn].king=false;
        canCastle[turn].rookA=false;
        history.push(m);
        enPassantTarget=null;
        return;
      }
    }
    // pawn double sets en passant target
    if(m.double){
      enPassantTarget = [(fr + tr)/2, fc];
    } else {
      enPassantTarget = null;
    }
    // promotion
    if(m.promotion){
      board[tr][tc] = (turn==='khaki'?'k':'b') + 'Q';
    } else {
      board[tr][tc] = board[fr][fc];
    }
    board[fr][fc]='';

    // if king or rook moved, disable castling rights
    if(piece[1]==='K'){
      canCastle[turn].king=false;
    }
    if(piece[1]==='R'){
      if(turn==='khaki'){
        if(fr===7 && fc===0) canCastle[turn].rookA=false;
        if(fr===7 && fc===7) canCastle[turn].rookH=false;
      } else {
        if(fr===0 && fc===0) canCastle[turn].rookA=false;
        if(fr===0 && fc===7) canCastle[turn].rookH=false;
      }
    }

    history.push(m);
  }

  function switchTurn(){
    turn = (turn==='khaki'?'black':'khaki');
  }

  function randomAIMove(){
    const moves = generateMoves(turn);
    if(moves.length===0) return null;
    return moves[Math.floor(Math.random()*moves.length)];
  }

  function checkWinner(){
    let khakiKing=false, blackKing=false;
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      if(board[r][c]==='kK') khakiKing=true;
      if(board[r][c]==='bK') blackKing=true;
    }
    if(!khakiKing) return 'AI (Black)';
    if(!blackKing) return 'You (Khaki)';
    return null;
  }

  // --- UI updates ---
  function updateUI(){
    boardEl.innerHTML='';
    for(let r=0;r<8;r++){
      for(let c=0;c<8;c++){
        const sq = document.createElement('div');
        sq.classList.add('square');
        sq.classList.add((r+c)%2===0 ? 'light':'dark');
        sq.dataset.r=r; sq.dataset.c=c;
        sq.setAttribute('aria-label', `Square ${coordsToAlgebraic([r,c])}`);
        const p = board[r][c];
        if(p){
          const d = document.createElement('div');
          d.classList.add('piece');
          const side = p[0]==='k' ? 'khaki':'black';
          d.classList.add(side);
          d.textContent = p[1];
          sq.appendChild(d);
        }
        if(selected && selected[0]===r && selected[1]===c){
          sq.classList.add('highlight');
        }
        sq.addEventListener('click', ()=>onSquareClick(r,c));
        boardEl.appendChild(sq);
      }
    }
    timerDisplay.textContent = timer;
    turnIndicator.textContent = (turn===playerColor? 'You':'AI') + `: ${turn==='khaki'?'Khaki':'Black'}`;
    moveHistoryEl.textContent = history.length ? history.map((m,i)=>{
      return `${i+1}.${coordsToAlgebraic(m.from)}${coordsToAlgebraic(m.to)}`;
    }).join(' ') : '-';
    const winner = checkWinner();
    if(winner){
      gameOver=true;
      winnerAnn.textContent = `Winner: ${winner}`;
      playSound(winner.includes('You')?'win':'lose');
      stopTimer();
    }
  }

  function onSquareClick(r,c){
    if(gameOver) return;
    if(turn!==playerColor) return;
    const moves = generateMoves(turn);
    // select piece
    if(selected){
      const attempted = moves.find(m=>m.from[0]===selected[0] && m.from[1]===selected[1] && m.to[0]===r && m.to[1]===c);
      if(attempted){
        applyMove(attempted);
        playSound('move');
        selected=null;
        switchTurn();
        updateUI();
        setTimeout(aiFlow, 300);
      } else {
        if(isOwn(r,c,turn)){
          selected=[r,c];
          updateUI();
        } else {
          selected=null;
          updateUI();
        }
      }
    } else {
      if(isOwn(r,c,turn)){
        selected=[r,c];
        updateUI();
      }
    }
  }

  // --- timer ---
  function startTurnTimer(){
    stopTimer();
    timer=30;
    updateUI();
    timerInterval = setInterval(()=>{
      timer--;
      if(timer<=10){
        playSound('tick');
      }
      if(timer<=0){
        clearInterval(timerInterval);
        if(gameOver) return;
        // lose turn
        switchTurn();
        updateUI();
        if(turn!==playerColor){
          setTimeout(aiFlow,200);
        } else {
          startTurnTimer();
        }
      } else {
        updateUI();
      }
    },1000);
  }
  function resetTimer(){
    timer=30;
    timerDisplay.textContent=timer;
    startTurnTimer();
  }
  function stopTimer(){
    if(timerInterval) clearInterval(timerInterval);
    timerInterval=null;
  }

  async function aiFlow(){
    if(gameOver) return;
    if(turn===playerColor) return;
    turnIndicator.textContent='AI thinking...';
    await new Promise(r=>setTimeout(r,500));
    const aiMove = randomAIMove();
    if(aiMove){
      applyMove(aiMove);
      playSound('move');
    }
    switchTurn();
    updateUI();
    if(!gameOver){
      startTurnTimer();
    }
  }

  // --- sounds ---
  function playSound(type){
    let el;
    if(type==='tick') el=document.getElementById('tick-sound');
    if(type==='move') el=document.getElementById('move-sound');
    if(type==='win') el=document.getElementById('win-sound');
    if(type==='lose') el=document.getElementById('lose-sound');
    if(el){
      try{
        el.currentTime=0;
        el.play();
      }catch(e){}
    }
  }

  // --- undo ---
  document.getElementById('undo-btn').addEventListener('click', ()=>{
    if(fullHistory.length===0) return;
    const lastState = fullHistory.pop();
    board = clone(lastState.board);
    enPassantTarget = lastState.enPassantTarget;
    canCastle = lastState.canCastle;
    history.pop();
    gameOver=false;
    winnerAnn.textContent='';
    turn = playerColor; // restore user turn for simplicity
    resetTimer();
    updateUI();
  });

  // --- controls ---
  document.getElementById('play-ai').addEventListener('click', ()=> resetGame(true));
  document.getElementById('reset-btn').addEventListener('click', ()=> resetGame(true));
  document.getElementById('theme-toggle').addEventListener('click', ()=>{
    const b = document.body;
    if(b.getAttribute('data-theme')==='dark'){
      b.setAttribute('data-theme','light');
      document.getElementById('theme-toggle').textContent='ðŸŒ™';
    } else {
      b.setAttribute('data-theme','dark');
      document.getElementById('theme-toggle').textContent='â˜€ï¸';
    }
  });
  document.getElementById('begin-btn').addEventListener('click', ()=>{
    document.getElementById('welcome-screen').classList.add('hidden');
    resetGame(true);
  });

  // --- init ---
  resetGame(true);
</script>
</body>
</html>
